{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Nest (NestPy) is a framework for building efficient, scalable\u00a0Python\u00a0server-side applications and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).</p> <p>Under the hood, Nest makes use of robust HTTP Server frameworks like\u00a0FastAPI\u00a0(the default) and optionally can be configured to use\u00a0Flask\u00a0(in development) as well!</p> <p>Nest provides a level of abstraction above these common Python frameworks (FastAPI/Flask), but also exposes their APIs directly to the developer. This gives developers the freedom to use the myriad of third-party modules which are available for the underlying platform.</p>"},{"location":"#philosophy","title":"Philosophy","text":"<p>Nest provides an out-of-the-box application architecture which allows developers and teams to create highly testable, scalable, loosely coupled, and easily maintainable applications. The architecture is heavily inspired by NestJS and Angular.</p>"},{"location":"#installation","title":"Installation","text":"<p>To get started, you can either scaffold the project with the Nest CLI, or clone a starter project (both will produce the same outcome).</p> <p>To scaffold the project with the Nest CLI, run the following commands. This will create a new project directory, and populate the directory with the initial core Nest files and supporting modules, creating a conventional base structure for your project. Creating a new project with the Nest CLI is recommended for first-time users. We'll continue with this approach in First Steps.</p> <pre><code>$ pip install nestpy-cli\n$ nest new project-name\n</code></pre>"},{"location":"#alternatives","title":"Alternatives","text":"<p>Alternatively, to install the Poetry starter project with Git:</p> <pre><code>$ git clone https://github.com/nestpy/poetry-starter.git project\n$ cd project\n$ poetry install\n$ poetry run start\n</code></pre> <p>info Hint If you'd like to clone the repository without the git history, you can use degit.</p> <p>Open your browser and navigate to <code>http://localhost:3000/</code>.</p> <p>To install the Pip flavor of the starter project, use <code>pip-starter.git</code> in the command sequence above.</p> <p>You can also manually create a new project from scratch by installing the core and supporting files with pip (or poetry). In this case, of course, you'll be responsible for creating the project boilerplate files yourself.</p> <pre><code>$ pip add nestpy-framework\n</code></pre>"},{"location":"cli/libraries/","title":"Libraries","text":""},{"location":"cli/libraries/#libraries","title":"Libraries","text":"<p>[ ... ]</p>"},{"location":"cli/libraries/#nest-libraries","title":"Nest libraries","text":"<p>[ ... ]</p>"},{"location":"cli/libraries/#creating-libraries","title":"Creating libraries","text":"<p>[ ... ]</p>"},{"location":"cli/libraries/#using-libraries","title":"Using libraries","text":"<p>[ ... ]</p>"},{"location":"cli/overview/","title":"Overview","text":""},{"location":"cli/overview/#overview","title":"Overview","text":"<p>The Nest CLI is a command-line interface tool that helps you to initialize, develop, and maintain your Nest applications. It assists in multiple ways, including scaffolding the project, serving it in development mode, and building and bundling the application for production distribution. It embodies best-practice architectural patterns to encourage well-structured apps.</p>"},{"location":"cli/overview/#installation","title":"Installation","text":"<p>[ ... ]</p>"},{"location":"cli/overview/#basic-workflow","title":"Basic workflow","text":"<p>[ ... ]</p>"},{"location":"cli/overview/#project-structure","title":"Project structure","text":"<p>[ ... ]</p>"},{"location":"cli/overview/#cli-command-syntax","title":"CLI command syntax","text":"<p>[ ... ]</p>"},{"location":"cli/overview/#command-overview","title":"Command overview","text":"<p>[ ... ]</p>"},{"location":"cli/overview/#requirements","title":"Requirements","text":"<p>[ ... ]</p>"},{"location":"cli/scripts/","title":"Scripts","text":""},{"location":"cli/scripts/#nest-cli-and-scripts","title":"Nest CLI and scripts","text":""},{"location":"cli/scripts/#the-nest-binary","title":"The nest binary","text":"<p>[ ... ]</p>"},{"location":"cli/scripts/#build","title":"Build","text":"<p>[ ... ]</p>"},{"location":"cli/scripts/#execution","title":"Execution","text":"<p>[ ... ]</p>"},{"location":"cli/scripts/#generation","title":"Generation","text":"<p>[ ... ]</p>"},{"location":"cli/scripts/#package-scripts","title":"Package scripts","text":"<p>[ ... ]</p>"},{"location":"cli/scripts/#backward-compatibility","title":"Backward compatibility","text":"<p>[ ... ]</p>"},{"location":"cli/scripts/#migration","title":"Migration","text":"<p>[ ... ]</p>"},{"location":"cli/usages/","title":"Usages","text":""},{"location":"cli/usages/#cli-command-reference","title":"CLI command reference","text":""},{"location":"cli/usages/#nest-new","title":"nest new","text":"<p>[ ... ]</p>"},{"location":"cli/usages/#nest-generate","title":"nest generate","text":"<p>[ ... ]</p>"},{"location":"cli/usages/#nest-build","title":"nest build","text":"<p>[ ... ]</p>"},{"location":"cli/usages/#nest-start","title":"nest start","text":"<p>[ ... ]</p>"},{"location":"cli/usages/#nest-add","title":"nest add","text":"<p>[ ... ]</p>"},{"location":"cli/usages/#nest-info","title":"nest info","text":"<p>[ ... ]</p>"},{"location":"cli/workspaces/","title":"Workspaces","text":""},{"location":"cli/workspaces/#workspaces","title":"Workspaces","text":"<p>[ ... ]</p>"},{"location":"cli/workspaces/#standard-mode","title":"Standard mode","text":"<p>[ ... ]</p>"},{"location":"cli/workspaces/#monorepo-mode","title":"Monorepo mode","text":"<p>[ ... ]</p>"},{"location":"cli/workspaces/#workspace-projects","title":"Workspace projects","text":"<p>[ ... ]</p>"},{"location":"cli/workspaces/#applications","title":"Applications","text":"<p>[ ... ]</p>"},{"location":"cli/workspaces/#libraries","title":"Libraries","text":"<p>[ ... ]</p>"},{"location":"cli/workspaces/#cli-properties","title":"CLI properties","text":"<p>[ ... ]</p>"},{"location":"cli/workspaces/#global-compiler-options","title":"Global compiler options","text":"<p>[ ... ]</p>"},{"location":"cli/workspaces/#global-generate-options","title":"Global generate options","text":"<p>[ ... ]</p>"},{"location":"cli/workspaces/#project-specific-generate-options","title":"Project-specific generate options","text":"<p>[ ... ]</p>"},{"location":"cli/workspaces/#specified-compiler","title":"Specified compiler","text":"<p>[ ... ]</p>"},{"location":"faq/global-prefix/","title":"Global prefix","text":""},{"location":"faq/global-prefix/#global-prefix","title":"Global prefix","text":"<p>To set a prefix for every route registered in an HTTP application, use the <code>setGlobalPrefix()</code> method of the <code>INestApplication</code> instance.</p> main.py<pre><code>app.setGlobalPrefix('/api')\n</code></pre> <p>You can exclude routes from the global prefix using the following construction:</p> <p>[ ... ]</p> <p>Alternatively, you can specify route as a string (it will apply to every request method):</p> <p>[ ... ]</p>"},{"location":"overview/controllers/","title":"Controllers","text":""},{"location":"overview/controllers/#controllers","title":"Controllers","text":"<p>Controllers are responsible for handling incoming requests and returning responses to the client.</p> <p>A controller's purpose is to receive specific requests for the application. The routing mechanism controls which controller receives which requests. Frequently, each controller has more than one route, and different routes can perform different actions.</p> <p>In order to create a basic controller, we use classes and decorators. Decorators associate classes with required metadata and enable Nest to create a routing map (tie requests to the corresponding controllers).</p>"},{"location":"overview/controllers/#routing","title":"Routing","text":"snakes_controller.py<pre><code>@Controller('snakes') # (1)\nclass AppController:\n\n    @Get() # (2)\n    async def findAll() -&gt; str:\n        return \"This action returns all snakes\"\n</code></pre> <ol> <li> <p>:man_raising_hand: I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</p> </li> <li> <p>:man_raising_hand: I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</p> </li> </ol> <p>The <code>@Get()</code> HTTP request method decorator before the <code>findAll()</code> method tells Nest to create a handler for a specific endpoint for HTTP requests. The endpoint corresponds to the HTTP request method (GET in this case) and the route path. What is the route path? The route path for a handler is determined by concatenating the (optional) prefix declared for the controller, and any path specified in the method's decorator. Since we've declared a prefix for every route ( <code>cats</code>), and haven't added any path information in the decorator, Nest will map <code>GET /snakes</code> requests to this handler. As mentioned, the path includes both the optional controller path prefix and any path string declared in the request method decorator. For example, a path prefix of <code>snakes</code> combined with the decorator <code>@Get('breed')</code> would produce a route mapping for requests like <code>GET /snakes/breed</code>.</p> <p>In our example above, when a GET request is made to this endpoint, Nest routes the request to our user-defined <code>findAll()</code> method. Note that the method name we choose here is completely arbitrary. We obviously must declare a method to bind the route to, but Nest doesn't attach any significance to the method name chosen.</p> <p>This method will return a 200 status code and the associated response, which in this case is just a string. Why does that happen? To explain, we'll first introduce the concept that Nest employs two different options for manipulating responses:</p> Standard (recommended)        Using this built-in method, when a request handler returns a dictionary or array, it will automatically       be serialized to JSON. When it returns a Python primitive type (e.g., <code>str</code>, <code>int</code>, <code>bool</code>), however, Nest will send just the value without attempting to serialize it. This makes response handling simple: just return the value, and Nest takes care of the rest.         Furthermore, the response's status code is always 200 by default, except for POST       requests which use 201. We can easily change this behavior by adding the <code>@HttpCode(...)</code>       decorator at a handler-level (see Status codes).      Library-specific        We can use the library-specific (e.g., FastAPI) response object, [ ... ]"},{"location":"overview/controllers/#request-object","title":"Request object","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#resources","title":"Resources","text":"<p>Earlier, we defined an endpoint to fetch the cats resource (GET route). We'll typically also want to provide an endpoint that creates new records. For this, let's create the POST handler:</p> snakes_controller.py<pre><code>@Controller('snakes')\nclass AppController:\n\n    @Get() # (1)\n    async def findAll() -&gt; str:\n        return \"This action returns all snakes\"\n\n    @Post() # (2)\n    async def create() -&gt; str:\n        return \"This action adds a new snake\"\n</code></pre> <ol> <li> <p>:man_raising_hand: I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</p> </li> <li> <p>:man_raising_hand: I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</p> </li> </ol> <p>It's that simple. Nest provides decorators for all of the standard HTTP methods: <code>@Get()</code>, <code>@Post()</code>, <code>@Put()</code>, <code>@Delete()</code>, <code>@Patch()</code>, <code>@Options()</code>, and <code>@Head()</code>. In addition, <code>@All()</code> defines an endpoint that handles all of them.</p>"},{"location":"overview/controllers/#route-wildcards","title":"Route wildcards","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#status-code","title":"Status code","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#headers","title":"Headers","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#redirection","title":"Redirection","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#route-parameters","title":"Route parameters","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#sub-domain-routing","title":"Sub-Domain Routing","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#scopes","title":"Scopes","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#asynchronicity","title":"Asynchronicity","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#request-payloads","title":"Request payloads","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#handling-errors","title":"Handling errors","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#full-resource-sample","title":"Full resource sample","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#getting-up-and-running","title":"Getting up and running","text":"<p>[ ... ]</p>"},{"location":"overview/controllers/#library-specific-approach","title":"Library-specific approach","text":"<p>[ ... ]</p>"},{"location":"overview/exception-filters/","title":"Exception filters","text":""},{"location":"overview/exception-filters/#exception-filters","title":"Exception filters","text":"<p>Nest comes with a built-in exceptions layer which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.</p> <p>[ ... ]</p> <p>Out of the box, this action is performed by a built-in global exception filter, which handles exceptions of type <code>HttpException</code> (and subclasses of it). When an exception is unrecognized (is neither <code>HttpException</code> nor a class that inherits from <code>HttpException</code>), the built-in exception filter generates the following default JSON response:</p>"},{"location":"overview/exception-filters/#throwing-standard-exceptions","title":"Throwing standard exceptions","text":"<p>[ ... ]</p>"},{"location":"overview/exception-filters/#custom-exceptions","title":"Custom exceptions","text":"<p>[ ... ]</p>"},{"location":"overview/exception-filters/#built-in-http-exceptions","title":"Built-in HTTP exceptions","text":"<p>[ ... ]</p>"},{"location":"overview/exception-filters/#exception-filters_1","title":"Exception filters","text":"<p>[ ... ]</p>"},{"location":"overview/exception-filters/#arguments-host","title":"Arguments host","text":"<p>[ ... ]</p>"},{"location":"overview/exception-filters/#binding-filters","title":"Binding filters","text":"<p>[ ... ]</p>"},{"location":"overview/exception-filters/#catch-everything","title":"Catch everything","text":"<p>[ ... ]</p>"},{"location":"overview/exception-filters/#inheritance","title":"Inheritance","text":"<p>[ ... ]</p>"},{"location":"overview/first-steps/","title":"First steps","text":"<p>In this set of articles, you'll learn the\u00a0core fundamentals\u00a0of Nest. To get familiar with the essential building blocks of Nest applications, we'll build a basic CRUD application with features that cover a lot of ground at an introductory level.</p>"},{"location":"overview/first-steps/#prerequisites","title":"Prerequisites","text":"<p>Please make sure that\u00a0Python\u00a0(version == 3.10) is installed on your operating system.</p>"},{"location":"overview/modules/","title":"Modules","text":""},{"location":"overview/modules/#modules","title":"Modules","text":"<p>A module is a class annotated with a <code>@Module()</code> decorator. The <code>@Module()</code> decorator provides metadata that Nest makes use of to organize the application structure.</p> <p>Each application has at least one module, a root module. The root module is the starting point Nest uses to build the application graph - the internal data structure Nest uses to resolve module and provider relationships and dependencies. While very small applications may theoretically have just the root module, this is not the typical case. We want to emphasize that modules are strongly recommended as an effective way to organize your components. Thus, for most applications, the resulting architecture will employ multiple modules, each encapsulating a closely related set of capabilities.</p> <p>The <code>@Module()</code> decorator takes a single object whose properties describe the module:</p> <code>providers</code> the providers that will be instantiated by the Nest injector and that may be shared at least across this module <code>controllers</code> the set of controllers defined in this module which have to be instantiated <code>imports</code> the list of imported modules that export the providers which are required in this module <code>exports</code> the subset of <code>providers</code> that are provided by this module and should be available in other modules which import this module. You can use either the provider itself or just its token (<code>provide</code> value) <p>The module encapsulates providers by default. This means that it's impossible to inject providers that are neither directly part of the current module nor exported from the imported modules. Thus, you may consider the exported providers from a module as the module's public interface, or API.</p>"},{"location":"overview/modules/#feature-modules","title":"Feature modules","text":"<p>The <code>SnakesController</code> and <code>SnakesService</code> belong to the same application domain. As they are closely related, it makes sense to move them into a feature module. A feature module simply organizes code relevant for a specific feature, keeping code organized and establishing clear boundaries. This helps us manage complexity and develop with SOLID principles, especially as the size of the application and/or team grow.</p> <p>To demonstrate this, we'll create the <code>SnakesModule</code>.</p> snakes_controller.py<pre><code>from nest.common.decorator import Module # (1)\nfrom .snakes_controller import SnakesController\nfrom .snakes_service import SnakesService\n\n@Module( # (2)\n    controllers=[SnakesController]\n    providers=[SnakesService]\n)\nclass SnakesModule:\n    pass\n</code></pre> <ol> <li> <p>:man_raising_hand: I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</p> </li> <li> <p>:man_raising_hand: I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</p> </li> </ol> <p>Above, we defined the SnakesModule in the Snakes.module.ts file, and moved everything related to this module into the Snakes directory. The last thing we need to do is import this module into the root module (the AppModule, defined in the app.module.ts file).</p> snakes/snakes_module.py<pre><code>from nest.common.decorator import Module # (1)\nfrom .snakes.snakes_module import SnakesModule\n\n@Module( # (2)\n    imports=[SnakesModule]\n)\nclass AppController:\n    pass\n</code></pre> <ol> <li> <p>:man_raising_hand: I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</p> </li> <li> <p>:man_raising_hand: I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</p> </li> </ol>"},{"location":"overview/modules/#shared-modules","title":"Shared modules","text":"<p>[ ... ]</p>"},{"location":"overview/modules/#module-re-exporting","title":"Module re-exporting","text":"<p>[ ... ]</p>"},{"location":"overview/modules/#dependency-injection","title":"Dependency injection","text":"<p>[ ... ]</p>"},{"location":"overview/modules/#global-modules","title":"Global modules","text":"<p>[ ... ]</p>"},{"location":"overview/modules/#dynamic-modules","title":"Dynamic modules","text":"<p>[ ... ]</p>"},{"location":"overview/providers/","title":"Providers","text":""},{"location":"overview/providers/#providers","title":"Providers","text":"<p>Providers are a fundamental concept in Nest. Many of the basic Nest classes may be treated as a provider \u2013 services, repositories, factories, helpers, and so on. The main idea of a provider is that it can be injected as a dependency; this means objects can create various relationships with each other, and the function of \"wiring up\" these objects can largely be delegated to the Nest runtime system.</p>"},{"location":"overview/providers/#services","title":"Services","text":"<p>[ ... ]</p>"},{"location":"overview/providers/#dependency-injection","title":"Dependency injection","text":"<p>[ ... ]</p>"},{"location":"overview/providers/#scopes","title":"Scopes","text":"<p>[ ... ]</p>"},{"location":"overview/providers/#custom-providers","title":"Custom providers","text":"<p>[ ... ]</p>"},{"location":"overview/providers/#optional-providers","title":"Optional providers","text":"<p>[ ... ]</p>"},{"location":"overview/providers/#property-based-injection","title":"Property-based injection","text":"<p>[ ... ]</p>"},{"location":"overview/providers/#provider-registration","title":"Provider registration","text":"<p>[ ... ]</p> <p>Now that we have defined a provider (<code>SnakesService</code>), and we have a consumer of that service (<code>SnakesController</code>), we need to register the service with Nest so that it can perform the injection. We do this by editing our module file (<code>snakes_module.py``) and adding the service to the</code>providers<code>array of the</code>@Module()` decorator.</p> <p>Nest will now be able to resolve the dependencies of the <code>SnakesController</code> class.</p> snakes_module.py<pre><code>from nest.common.decorators import Module\n\nfrom snakes.snakes_controller import SnakesController \nfrom snakes.snakes_service import SnakesService\n\n@Module(\n    controllers=[SnakesController], # (1)\n    providers=[SnakesService] # (2)\n)\nclass SnakesModule: \n    pass\n</code></pre> <ol> <li> <p>:man_raising_hand: I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</p> </li> <li> <p>:man_raising_hand: I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</p> </li> </ol> <p>This is how our directory structure should look now:</p> <p>[ ... ]</p>"},{"location":"overview/providers/#manual-instantiation","title":"Manual instantiation","text":"<p>[ ... ]</p>"},{"location":"security/cors/","title":"Cors","text":""},{"location":"security/cors/#cors","title":"CORS","text":"<p>[ ... ]</p>"},{"location":"security/cors/#getting-started","title":"Getting started","text":"<p>[ ... ]</p>"},{"location":"techniques/versioning/","title":"Versioning","text":""},{"location":"techniques/versioning/#versioning","title":"Versioning","text":"<p>Versioning allows you to have different versions of your controllers or individual routes running within the same application. Applications change very often and it is not unusual that there are breaking changes that you need to make while still needing to support the previous version of the application.</p> <p>There are 4 types of versioning that are supported:</p> <code>URI Versioning</code> The version will be passed within the URI of the request (default) <code>Header Versioning</code> A custom request header will specify the version <code>Media Type Versioning</code> The <code>Accept</code> header of the request will specify the version <code>Custom Versioning</code> Any aspect of the request may be used to specify the version(s). A custom function is provided to extract said version(s)."},{"location":"techniques/versioning/#uri-versioning-type","title":"URI Versioning Type","text":"<p>URI Versioning uses the version passed within the URI of the request, such as https://example.com/v1/route and https://example.com/v2/route.</p> <p>Notice  With URI Versioning the version will be automatically added to the URI after the global path prefix (if one exists), and before any controller or route paths.</p> <p>To enable URI Versioning for your application, do the following:</p> main.py<pre><code>app = NestApplication( AppModule )\n\napp.enableVersioning(type=VersioningType.URI)\n\napp.listen(port=3000)\n</code></pre> <p>Notice  The version in the URI will be automatically prefixed with <code>v</code> by default, however the prefix value can be configured by setting the <code>prefix</code> key to your desired prefix or <code>false</code> if you wish to disable it.</p> <p>info Hint The <code>VersioningType</code> enum is available to use for the <code>type</code> property and is imported from the <code>nest.common</code> package.</p>"},{"location":"techniques/versioning/#header-versioning-type","title":"Header Versioning Type","text":"<p>[ ... ]</p>"},{"location":"techniques/versioning/#media-type-versioning-type","title":"Media Type Versioning Type","text":"<p>[ ... ]</p>"},{"location":"techniques/versioning/#custom-versioning-type","title":"Custom Versioning Type","text":"<p>[ ... ]</p>"},{"location":"techniques/versioning/#usage","title":"Usage","text":"<p>[ ... ]</p>"},{"location":"techniques/versioning/#controller-versions","title":"Controller versions","text":"<p>[ ... ]</p>"},{"location":"techniques/versioning/#route-versions","title":"Route versions","text":"<p>[ ... ]</p>"},{"location":"techniques/versioning/#multiple-versions","title":"Multiple versions","text":"<p>[ ... ]</p>"},{"location":"techniques/versioning/#version-neutral","title":"Version \"Neutral\"","text":"<p>[ ... ]</p>"},{"location":"techniques/versioning/#global-default-version","title":"Global default version","text":"<p>If you do not want to provide a version for each controller/or individual routes, or if you want to have a specific version set as the default version for every controller/route that don't have the version specified, you could set the <code>defaultVersion</code> as follows:</p> main.py<pre><code>app = NestApplication( AppModule )\n\napp.enableVersioning(\n  type=VersioningType.URI, \n  defaultVersioning='2'\n)\n\napp.listen(port=3000)\n</code></pre>"},{"location":"techniques/versioning/#middleware-versioning","title":"Middleware versioning","text":"<p>[ ... ]</p>"}]}